
#### 1.移除元素
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // 双指针 原地移除 val元素

        //先来个暴力解法
        /*
        int n = nums.length;
        for(int i=0;i<n;i++){
            if(nums[i] == val){
                for(int j=i+1;j<n;j++){
                    nums[j-1] = nums[j];
                }
                i--;
                n--;
            }
        }
        return n;
        */
        // 双指针  快慢
        int n = nums.length, slow = 0 ,fast = 0;
        while(fast<n){
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
}
```

#### 2.有序数组的平方
```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        // 平方 非递减 可能有负数
        /*
        //1.直接暴力排序
        int n = nums.length;
        for(int i=0; i<n; i++){
            nums[i] *= nums[i];
        }
        Arrays.sort(nums);
        return nums;
        */

        // 2. 双指针 最大的值在两端
        int n = nums.length, left = 0, right = n-1;
        int[] result = new int[n];
        int index = n - 1;
        while(left<=right){
            int l = nums[left] * nums[left];
            int r = nums[right] * nums[right];
            if(l<r) {
                result[index] = r;
                index--;
                right--;
            }
            else {
                result[index] = l;
                index--;
                left++;
            }
        }
        return result;
    }
}
```

#### 3.长度最小的子数组
[链接](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)
滑动窗口的思想，把双层遍历变为一层for循环，本质还是一个双指针
```java

class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        // 要找的是连续数组 满足>=target
        //滑动窗口 就是要用一个for循环搞定 暴力是2个for循环
        int left = 0;
        int sum = 0;
        int result = Integer.MAX_VALUE;
        for(int right = 0; right<nums.length;right++){
            sum += nums[right];
            while(sum >= target){ // 如果满足了条件 那么就要去找一个最小的长度 所以是while
                result = Math.min(result,right-left+1);
                sum -= nums[left++]; // 不断变更起始位置
            }
        } 
    return result == Integer.MAX_VALUE ? 0 : result;
    }
}

// 暴力解法 超时
/*
class Solution{
public int minSubArrayLen(int s, int[] nums) {
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            int sum = nums[i];
            if (sum >= s)
                return 1;
            for (int j = i + 1; j < nums.length; j++) {
                sum += nums[j];
                if (sum >= s) {
                    min = Math.min(min, j - i + 1);
                    break;
                }
            }
        }
        return min == Integer.MAX_VALUE ? 0 : min;
    }
}
*/

    

```
#### 4.水果成篮
[链接](https://leetcode.cn/problems/fruit-into-baskets/solutions/3018030/hua-dong-chuang-kou-wen-ti-de-tong-jie-j-zwys/)
```java
class Solution {
    public int totalFruit(int[] fruits) {
        //找至多包含两种元素的最长子串，返回其长度

        // 存储的是水果种类，两个篮子，每个篮子只能装一种水果
        // 一棵树只能摘一个果子 找最大数目
        //滑动窗口 最大种类不超过两种： 考虑哈希表 2个键值对
        int left = 0;
        Map<Integer,Integer> cnt = new HashMap<>();
        int n = fruits.length; //树个数
        int result = 0;
        for(int right = 0; right<n; right++){
            cnt.put(fruits[right],cnt.getOrDefault(fruits[right], 0) + 1);
            while(cnt.size()>2){
                cnt.put(fruits[left],cnt.get(fruits[left]) -1); //重新赋值
                if (cnt.get(fruits[left]) == 0) {
                    cnt.remove(fruits[left]);
                }
                left++;
            }
            result = Math.max(result,right-left+1);
        }
    return result;
    }
}
```

#### 5.螺旋矩阵
总的来说就是模拟过程
模拟顺时针画矩阵的过程:
填充上行从左到右
填充右列从上到下
填充下行从右到左
填充左列从下到上
**边界条件非常多**

![[pictures/Pasted image 20250124011509.png]]
```java
class Solution {
    public int[][] generateMatrix(int n) {
        int l = 0, r = n-1, t = 0, b = n-1;
        int[][] result = new int[n][n];
        int num = 1, tar = n*n;
        while(num<=tar){
            //上
            for(int i=l;i<=r;i++) result[t][i] = num++;
            t++;
            //右
            for(int i=t;i<=b;i++) result[i][r] = num++;
            r--;
            //下
            for(int i=r;i>=l;i--) result[b][i] = num++;
            b--;
            //左
            for(int i=b;i>=t;i--) result[i][l] = num++;
            l++;
        }
        return result;
    }
}
```

变式：顺时针输出矩阵元素：m * n

```java

class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        // m * n 行数 matrix.length 列数 matrix[0].length
        int l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1;
        List<Integer> list = new ArrayList<>();
        int temp  = (r+1) * (b+1);
        while (list.size() < temp) {
            // 上
            for (int i = l; i <= r; i++) {
                list.add(matrix[t][i]);
                if(list.size() ==  temp  ) return list;
            }
            t++;
            // 右
            for (int i = t; i <= b; i++) {
                list.add(matrix[i][r]);
                if(list.size() == temp ) return list;
            }
            r--;
            // 下
                for (int i = r; i >= l; i--) {
                    list.add(matrix[b][i]);
                    if(list.size() == temp ) return list;
                }
                b--;
            
            // 左
                for (int i = b; i >= t; i--) {
                    list.add(matrix[i][l]);
                    if(list.size() == temp ) return list;
                }
                l++;
        }
        return list;
    }
}

```

#### 6.区间和
